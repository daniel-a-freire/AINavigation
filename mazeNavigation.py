import time, psutil, queue
import argparse

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Robot Path Planning | HW 1 | COMS 4701')
	parser.add_argument('-bfs', action="store_true", default=False , help="Run BFS on the map")
	parser.add_argument('-dfs', action="store_true", default=False, help= "Run DFS on the map")
	parser.add_argument('-astar', action="store_true", default=False, help="Run A* on the map")
	parser.add_argument('-ida', action="store_true", default=False, help="Run Iterative Deepening A* on the map")
	parser.add_argument('-all', action="store_true", default=False, help="Run all the 4 algorithms")
	parser.add_argument('-m', action="store", help="Map filename")

	results = parser.parse_args()

	if results.m=="" or not(results.all or results.astar or results.bfs or results.dfs or results.ida):
		print("Check the parameters : >> python hw1_UNI.py -h")
		exit()

	if results.all:
		results.bfs = results.dfs = results.astar = results.ida = True

	# Reading of map given and all other initializations
	try:
		with open(results.m) as f:
			arena = f.read()
			arena = arena.split("\n")
	except:
		print("Error in reading the arena file.")
		exit()

	# Internal representation
	print(arena)

	print("The arena of size "+ str(len(arena)) + "x" + str(len(arena[0])))
	print("\n".join(arena))

class MazeState:
	'''
	This class is an abstraction to store a maze state, which contains the following:
	- Maze configuration (arena)
	- Current Position (position in the the maze that the current state represents)
	- Parent (the state from which the current state came from)
	- Action (the action taken in the parent state, direction moved, which lead to the creation of the current state)
	- Cost (Cost  of the path taken from the start to the current state)
	- Children (a child of the current state is generated by moving in a direction)
	'''
	
	def get_start_index(self):
		'''
		Returns the start index of the maze based on the given arena
		returns (-1, -1) if no start index found
		'''
        
		start_index = (-1, -1)
        
		for row_index, row in enumerate(self.arena):
		    for column_index, column in enumerate(row):
		        if self.arena[row_index][column_index] == 's':
		            return (row_index, column_index)
                    
		return start_index

	def get_goal_index(self):
		'''
		Returns the goal index of the maze based on the given arena
		returns (-1, -1) if no goal index found
		'''
		
		goal_index = (-1, -1)
        
		for row_index, row in enumerate(self.arena):
		    for column_index, column in enumerate(row):
		        if self.arena[row_index][column_index] == 'g':
		            return (row_index, column_index)
                    
		return goal_index

	def __init__(self, arena, parent=None, action='Start', cost=0, current_position=(-1,-1)):

		self.arena = arena
		self.parent = parent
		self.action = action
		self.cost = cost
		self.children = []

		self.start = self.get_start_index()
		self.goal = self.get_goal_index()

		if(current_position[0] == -1):
			self.current_position = self.start
		else:
			self.current_position = current_position

	def display(self):
		print("\n".join(self.arena))

	def move_up(self):
		'''
		This function checks if up is a valid move from the given state.
		If up is a valid move, returns a child in which the player has moved up
		Else returns None.
		'''
        
		if (not self.current_position[0] - 1 < 0) and (self.arena[self.current_position[0] - 1][self.current_position[1]] == " " or self.arena[self.current_position[0] - 1][self.current_position[1]] == "g"):
		    modified_arena = self.arena[:]
		    modified_arena[self.current_position[0]] = modified_arena[self.current_position[0]][0:self.current_position[1]] + "*" + modified_arena[self.current_position[0]][self.current_position[1] + 1::] if modified_arena[self.current_position[0]][self.current_position[1]] != "s" else modified_arena[self.current_position[0]]
            
		    return MazeState(modified_arena, self, 'Up', self.cost + 1, (self.current_position[0] - 1, self.current_position[1]))
		
		return None

	def move_down(self):
		'''
		This function checks if down is a valid move from the given state.
		If down is a valid move, returns a child in which the player has moved down.
		Else returns None.
		'''
        
		if (not self.current_position[0] + 1 > len(self.arena) - 1) and (self.arena[self.current_position[0] + 1][self.current_position[1]] == " " or self.arena[self.current_position[0] + 1][self.current_position[1]] == "g"):
		    modified_arena = self.arena[:]
		    modified_arena[self.current_position[0]] = modified_arena[self.current_position[0]][0:self.current_position[1]] + "*" + modified_arena[self.current_position[0]][self.current_position[1] + 1::] if modified_arena[self.current_position[0]][self.current_position[1]] != "s" else modified_arena[self.current_position[0]]
            
		    return MazeState(modified_arena, self, 'Down', self.cost + 1, (self.current_position[0] + 1, self.current_position[1]))
		
		return None

	def move_left(self):
		'''
		This function checks if left is a valid move from the given state.
		If left is a valid move, returns a child in which the player has moved left.
		Else returns None.
		'''
        
		if (not self.current_position[1] - 1 < 0) and (self.arena[self.current_position[0]][self.current_position[1] - 1] == " " or self.arena[self.current_position[0]][self.current_position[1] - 1] == "g"):
		    modified_arena = self.arena[:]
		    modified_arena[self.current_position[0]] = modified_arena[self.current_position[0]][0:self.current_position[1]] + "*" + modified_arena[self.current_position[0]][self.current_position[1] + 1::] if modified_arena[self.current_position[0]][self.current_position[1]] != "s" else modified_arena[self.current_position[0]]
            
		    return MazeState(modified_arena, self, 'Left', self.cost + 1, (self.current_position[0], self.current_position[1] - 1))
		
		return None

	def move_right(self):
		'''
		This function checks if left is a valid move from the given state.
		If left is a valid move, returns a child in which the player has moved left.
		Else returns None.
		'''
        
		if (not self.current_position[1] + 1 > len(self.arena[0]) - 1) and (self.arena[self.current_position[0]][self.current_position[1] + 1] == " " or self.arena[self.current_position[0]][self.current_position[1] + 1] == "g"):
		    modified_arena = self.arena[:]
		    modified_arena[self.current_position[0]] = modified_arena[self.current_position[0]][0:self.current_position[1]] + "*" + modified_arena[self.current_position[0]][self.current_position[1] + 1::] if modified_arena[self.current_position[0]][self.current_position[1]] != "s" else modified_arena[self.current_position[0]]
            
		    return MazeState(modified_arena, self, 'Right', self.cost + 1, (self.current_position[0], self.current_position[1] + 1))
		
		return None

	def expand(self):
		""" 
		Generate the child nodes of this node 
		"""
		
		if(len(self.children) != 0):
			return self.children

		# Do not change the order in this function, since the grading script assumes this order of expansion when checking
		children = [self.move_up(), self.move_right(), self.move_down(), self.move_left()]

		self.children = [state for state in children if state is not None]
		return self.children
		
	def __hash__(self):
		'''
		Maze states hashed based on cost. 
		This function may be modified if required.
		'''
		
		return self.cost
		
	def __eq__(self, other):
		'''
		Maze states are defined as equal if they have the same dimensions and the same current position. 
		This function may be modified if required.
		'''
		
		m1 = self.arena
		m2 = other.arena

		if(len(m1) != len(m2)):
			return False

		for i in range(0, len(m1)):
			if(not (m1[i] == m2[i])):
				return False
				
		return self.current_position == other.current_position

'''
This function runs Breadth First Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def bfs(arena):

    # Function to get the memory usage of the program
	def memory_usage():
	    return psutil.Process().memory_info().rss / (1024 * 1024)
    
    # Calculate the time and memory at the beginning of the BFS function
	start_memory = memory_usage()
	start_time = time.time()
    
    # Initialize the starting node
	start_node = MazeState(arena, None, 'Start', 0, (-1,-1))
	start_node.current_position = start_node.start
    
    # Initialize the queue (the frontier) and the explored set and the combined set
	bfs_queue = [start_node]
	bfs_queue_set = set([start_node.current_position])
	explored = set()
	combined_set = set()
    
    # Initialize the counts for nodes expanded, max nodes stored at once, and max cost seen
	nodes_expanded = 0
	max_nodes_stored_at_once = 0
	max_cost = 0
    
    # While the queue (frontier) is not empty
	while bfs_queue:
        # Retrieve the current node to be processed and expanded
	    current_processing_node = bfs_queue.pop(0)
	    bfs_queue_set.remove(current_processing_node.current_position)
	    explored.add(current_processing_node.current_position)
	    combined_set.add(current_processing_node.current_position)

	    # Checking the combination of the queue (frontier) and seen
	    if len(combined_set) > max_nodes_stored_at_once:
            # Updating max nodes stored at once
	        max_nodes_stored_at_once = len(combined_set)
        
        # Once the goal is finally reached
	    if current_processing_node.current_position == current_processing_node.goal:  
            # Calculate the time and memory at the end of the BFS function
	        end_time = time.time()
	        end_memory = memory_usage()
	        execution_time = end_time - start_time
	        memory_used = end_memory - start_memory
            
            # Return all the information from the run of the algorithm
	        return (current_processing_node.arena, current_processing_node.cost, nodes_expanded, max_nodes_stored_at_once, max_cost, execution_time, memory_used)
        
	    # Expand the node
	    current_processing_node.children = current_processing_node.expand()
	    nodes_expanded += 1
        
        # For each child of the current node
	    for child in current_processing_node.children:
            # If the child is not in the queue (frontier) and has not been explored
	        if child.current_position not in bfs_queue_set and child.current_position not in explored:   
                # Checking the current max cost seen so far
        	    if child.cost > max_cost:      
        	        max_cost = child.cost

                # Add the child into the queue (frontier)   
	            bfs_queue.append(child)
	            bfs_queue_set.add(child.current_position)
	            combined_set.add(child.current_position)
                
    # Returning failure if there is one
	return [], -1, -1, -1, -1, -1, -1

'''
This function runs Depth First Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def dfs(arena):

    # Function to get the memory usage of the program
	def memory_usage():
	    return psutil.Process().memory_info().rss / (1024 * 1024)
    
    # Calculate the time and memory at the beginning of the DFS function
	start_memory = memory_usage()
	start_time = time.time()
    
    # Initialize the starting node
	start_node = MazeState(arena, None, 'Start', 0, (-1,-1))
	start_node.current_position = start_node.start
    
    # Initialize the stack (the frontier) and the explored set and the combined set
	dfs_stack = [start_node]
	dfs_stack_set = set([start_node.current_position])
	explored = set()
	combined_set = set()
    
    # Initialize the counts for nodes expanded, max nodes stored at once, and max cost seen
	nodes_expanded = 0
	max_nodes_stored_at_once = 0
	max_cost = 0
    
    # While the stack (frontier) is not empty
	while dfs_stack:
        # Retrieve the current node to be processed and expanded
	    current_processing_node = dfs_stack.pop()
	    dfs_stack_set.remove(current_processing_node.current_position)
	    explored.add(current_processing_node.current_position)
	    combined_set.add(current_processing_node.current_position)

	    # Checking the combination of the stack (frontier) and seen
	    if len(combined_set) > max_nodes_stored_at_once:
            # Updating max nodes stored at once
	        max_nodes_stored_at_once = len(combined_set)
        
        # Once the goal is finally reached
	    if current_processing_node.current_position == current_processing_node.goal:  
            # Calculate the time and memory at the end of the DFS function
	        end_time = time.time()
	        end_memory = memory_usage()
	        execution_time = end_time - start_time
	        memory_used = end_memory - start_memory
            
            # Return all the information from the run of the algorithm
	        return (current_processing_node.arena, current_processing_node.cost, nodes_expanded, max_nodes_stored_at_once, max_cost, execution_time, memory_used)
        
	    # Expand the node
	    current_processing_node.children = current_processing_node.expand()
	    nodes_expanded += 1
        
        # For each child of the current node
	    for child in current_processing_node.children[::-1]:
            # If the child is not in the stack (frontier) and has not been explored
	        if child.current_position not in dfs_stack_set and child.current_position not in explored:   
                # Checking the current max cost seen so far
        	    if child.cost > max_cost:      
        	        max_cost = child.cost
                    
                # Add the child into the stack (frontier)   
	            dfs_stack.append(child)
	            dfs_stack_set.add(child.current_position)
	            combined_set.add(child.current_position)

	# Returning failure if there is one
	return [], -1, -1, -1, -1, -1, -1

	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#

'''
This function runs A* Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def astar(arena):

    # Function to get the memory usage of the program
	def memory_usage():
	    return psutil.Process().memory_info().rss / (1024 * 1024)

    # Function to calculate total cost of a given node
	def cheapest_solution_through_given_node(given_node):
	    cost_to_reach_given_node = given_node.cost
	    cost_from_given_node_to_goal = abs(given_node.current_position[0] - given_node.goal[0]) + abs(given_node.current_position[1] - given_node.goal[1])
	    return cost_to_reach_given_node + cost_from_given_node_to_goal
    
    # Calculate the time and memory at the beginning of the A* function
	start_memory = memory_usage()
	start_time = time.time()
    
    # Initialize the starting node
	start_node = MazeState(arena, None, 'Start', 0, (-1,-1))
	start_node.current_position = start_node.start
    
    # Variable used to help resolve conflicts with nodes that share the same priority
	order_of_occurrence = 0
    
    # Initialize the queue (the frontier) and the explored set and the combined set
	astar_priority_queue = queue.PriorityQueue()
	astar_priority_queue.put((cheapest_solution_through_given_node(start_node), order_of_occurrence, start_node))
	order_of_occurrence += 1
	astar_priority_queue_set = set([start_node.current_position])
	explored = set()
	combined_set = set()
	position_cost_dictionary = dict()
    
    # Initialize the counts for nodes expanded, max nodes stored at once, and max cost seen
	nodes_expanded = 0
	max_nodes_stored_at_once = 0
	max_cost = 0
    
    # While the priority queue (frontier) is not empty
	while not astar_priority_queue.empty():
        # Retrieve the current node to be processed and expanded
	    retrieved_node = astar_priority_queue.get()
	    current_processing_node_priority = retrieved_node[0]
	    current_processing_node = retrieved_node[2]
	    explored.add(current_processing_node.current_position)
	    combined_set.add(current_processing_node.current_position)
            
        # Taking into account stale nodes that should not be considered, essentially a position that doesn't match its current agreed upon lowest path cost since it is using an older version with its older higher cost
	    if current_processing_node.current_position in position_cost_dictionary and current_processing_node_priority != position_cost_dictionary[current_processing_node.current_position]:
            # Have the stale node not be processed at all through the algorithm, so skip doing work for it
	        continue
            
	    # Remove node from priority queue set        
	    astar_priority_queue_set.remove(current_processing_node.current_position)
	    position_cost_dictionary[current_processing_node.current_position] = current_processing_node_priority

	    # Checking the combination of the priority queue (frontier) and seen
	    if len(combined_set) > max_nodes_stored_at_once:
            # Updating max nodes stored at once
	        max_nodes_stored_at_once = len(combined_set)
        
        # Once the goal index is finally reached
	    if current_processing_node.current_position == current_processing_node.goal:
            # Calculate the time and memory at the end of the A* function
	        end_time = time.time()
	        end_memory = memory_usage()
	        execution_time = end_time - start_time
	        memory_used = end_memory - start_memory
            
            # Return all the information from the run of the algorithm
	        return (current_processing_node.arena, current_processing_node.cost, nodes_expanded, max_nodes_stored_at_once, max_cost, execution_time, memory_used)
        
	    # Expand the node
	    current_processing_node.children = current_processing_node.expand()
	    nodes_expanded += 1
        
        # For each child of the current node
	    for child in current_processing_node.children:
            # Calculate the total priority cost of the child
	        child_cost = cheapest_solution_through_given_node(child)
            
            # If the child is not in the priority queue (frontier) and has not been explored
	        if child.current_position not in astar_priority_queue_set and child.current_position not in explored:   
                # Checking the current max cost seen so far
        	    if child.cost > max_cost:      
        	        max_cost = child.cost
                    
                # Add the child into the priority queue (frontier)   
	            astar_priority_queue.put((child_cost, order_of_occurrence, child))
	            order_of_occurrence += 1
	            astar_priority_queue_set.add(child.current_position)
	            position_cost_dictionary[child.current_position] = child_cost
	            combined_set.add(child.current_position)
            # If the child is in the priority queue (frontier)
	        elif child.current_position in astar_priority_queue_set:
                # If the cost of the child is now lower than previously documented
	            if child_cost < position_cost_dictionary[child.current_position]:
                    # Update the re-explored position with the new cost
	                position_cost_dictionary[child.current_position] = child_cost
                    # Add back the re_explored position into the queue (frontier) with the new cost
	                astar_priority_queue.put((child_cost, order_of_occurrence, child))
	                order_of_occurrence += 1
                
    # Returning failure if there is one
	return [], -1, -1, -1, -1, -1, -1
	
'''
This function runs Iterative Deepening A* Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def ida(arena):

    # Function to get the memory usage of the program
	def memory_usage():
	    return psutil.Process().memory_info().rss / (1024 * 1024)

    # Function to calculate total cost of a given node
	def cheapest_solution_through_given_node(given_node):
	    cost_to_reach_given_node = given_node.cost
	    cost_from_given_node_to_goal = abs(given_node.current_position[0] - given_node.goal[0]) + abs(given_node.current_position[1] - given_node.goal[1])
	    return cost_to_reach_given_node + cost_from_given_node_to_goal

    # Depth Limited Search helper function with a cost limit threshold
	def dfs_limited(current_processing_node, current_cost_limit, current_min_cost_exceeded, expanding_nodes, max_storing_nodes, max_costing, combining_set):
        # Process the total cost for the current node
	    current_total_cost = cheapest_solution_through_given_node(current_processing_node)
        # Consider node in calculating the max nodes stored at once
	    combining_set.add(current_processing_node.current_position)

        # If the current node total cost exceeds the current cost limit
	    if current_total_cost > current_cost_limit:
            # Update the minimum cost that was exceeded
	        current_min_cost_exceeded[0] = min(current_min_cost_exceeded[0], current_total_cost)
            # No solution found in this iteration
	        return None
        
        # Check on the number of nodes stored at the moment
	    if len(combining_set) > max_storing_nodes[0]:
            # Update the number of max nodes stored at once
	        max_storing_nodes[0] = len(combining_set)

        # If the goal is reached
	    if current_processing_node.current_position == current_processing_node.goal:
            # Return the current node
	        return current_processing_node

        # Expand the node
	    current_processing_node.children = current_processing_node.expand()
	    expanding_nodes[0] += 1
        
        # For each child of the current node
	    for child in current_processing_node.children:
            # Do a recursive DFS call within the current cost limit
	        result = dfs_limited(child, current_cost_limit, current_min_cost_exceeded, expanding_nodes, max_storing_nodes, max_costing, combining_set)
            
            # If a result node was found
	        if result is not None:
                # Checking the current max cost seen so far
        	    if child.cost > max_costing[0]:      
        	        max_costing[0] = child.cost
                    
                # Update the number of nodes stored at the moment
	            combining_set.add(child.current_position)
                # Return the result node found
	            return result

        # No solution found in this iteration
	    return None

    # Calculate the time and memory at the beginning of the IDA* function
	start_memory = memory_usage()
	start_time = time.time()

    # Initialize the starting node
	start_node = MazeState(arena, None, 'Start', 0, (-1, -1))
	start_node.current_position = start_node.start

    # Set the initial cost limit to the heuristic cost of the start node (total cost for the start node is just its heuristic cost)
	cost_limit = cheapest_solution_through_given_node(start_node)

    # Initialize the counts for nodes expanded, max nodes stored at once, and max cost seen
	nodes_expanded = [0]
	max_nodes_stored_at_once = [0]
	max_cost = [0]
    
    # Initialize combined set to help keep track of max nodes stored at once
	combined_set = set()

    # Perform IDA* search
	while True:
        # Initialize variable to keep track of the minimum cost that exceeds the current cost limit
	    min_cost_exceeded = [float('inf')]

        # Run Depth Limited Search helper function with the current cost limit
	    result = dfs_limited(start_node, cost_limit, min_cost_exceeded, nodes_expanded, max_nodes_stored_at_once, max_cost, combined_set)

        # If solution is found
	    if result is not None:
            # Calculate the time and memory at the end of the IDA* function
	        end_time = time.time()
	        end_memory = memory_usage()
	        execution_time = end_time - start_time
	        memory_used = end_memory - start_memory
            
            # Return all the information from the run of the algorithm
	        return (result.arena, result.cost, nodes_expanded[0], max_nodes_stored_at_once[0], max_cost[0], execution_time, memory_used)
        
        # If no solution is found
	    if min_cost_exceeded[0] == float('inf'):
            # Returning failure if there is one
	        return [], -1, -1, -1, -1, -1, -1

        # Increase the current cost limit to the minimum total cost that exceeded the current cost limit
	    cost_limit = min_cost_exceeded[0]

if __name__ == "__main__":
	if results.bfs:
		print("\nBFS algorithm called")
		bfs_arena, bfs_cost, bfs_nodes_expanded, bfs_max_nodes_stored, bfs_max_search_depth, bfs_time, bfs_ram = bfs(arena)
		print("\n".join(bfs_arena))
		print("BFS:")
		print("Cost: " + str(bfs_cost))
		print("Nodes Expanded: " + str(bfs_nodes_expanded))
		print("Max Nodes Stored: " + str(bfs_max_nodes_stored))
		print("Max Search Depth: " + str(bfs_max_search_depth))
		print("Time: " + str(bfs_time) + "s")
		print("RAM Usage: " + str(bfs_ram) + "kB\n")

	if results.dfs:
		print("\nDFS algorithm called")
		dfs_arena, dfs_cost, dfs_nodes_expanded, dfs_max_nodes_stored, dfs_max_search_depth, dfs_time, dfs_ram = dfs(arena)
		print("\n".join(dfs_arena))
		print("DFS:")
		print("Cost: " + str(dfs_cost))
		print("Nodes Expanded: " + str(dfs_nodes_expanded))
		print("Max Nodes Stored: " + str(dfs_max_nodes_stored))
		print("Max Search Depth: " + str(dfs_max_search_depth))
		print("Time: " + str(dfs_time) + "s")
		print("RAM Usage: " + str(dfs_ram) + "kB\n")

	if results.astar:
		print("\nA* algorithm called")
		astar_arena, astar_cost, astar_nodes_expanded, astar_max_nodes_stored, astar_max_search_depth, astar_time, astar_ram = astar(arena)
		print("\n".join(astar_arena))
		print("A*:")
		print("Cost: " + str(astar_cost))
		print("Nodes Expanded: " + str(astar_nodes_expanded))
		print("Max Nodes Stored: " + str(astar_max_nodes_stored))
		print("Max Search Depth: " + str(astar_max_search_depth))
		print("Time: " + str(astar_time) + "s")
		print("RAM Usage: " + str(astar_ram) + "kB\n")
	
	if results.ida:
		print("\nIterative Deepening A* algorithm called")
		ida_arena, ida_cost, ida_nodes_expanded, ida_max_nodes_stored, ida_max_search_depth, ida_time, ida_ram = ida(arena)
		print("\n".join(ida_arena))
		print("Iterative Deepening A*:")
		print("Cost: " + str(ida_cost))
		print("Nodes Expanded: " + str(ida_nodes_expanded))
		print("Max Nodes Stored: " + str(ida_max_nodes_stored))
		print("Max Search Depth: " + str(ida_max_search_depth))
		print("Time: " + str(ida_time) + "s")
		print("RAM Usage: " + str(ida_ram) + "kB\n")

